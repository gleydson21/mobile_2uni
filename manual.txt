ğŸ“ back_end/
 | â””â”€ ğŸ“ instance/
 |       â””â”€vendas.db
 | â””â”€ ğŸ“ venv/
 |     |  â””â”€ğŸ“ include/
 |     |  â””â”€ğŸ“ lib/
 |     |  â””â”€ğŸ“ Scripts/
 |     â””â”€ğŸ“„ pyvenv.cfg 
 |     
ğŸ“„ app.py
ğŸ“„ requierements.txt 

ğŸ“ lib/
 |  â””â”€ ğŸ“ authentication/
 |        â””â”€ğŸ”’ authentication.dart
 |        
 |        
 |  â””â”€ ğŸ“ components/
 |        â””â”€ ğŸ›’ ecommerce_items.dart
 |       
 |  â””â”€ ğŸ“ images/
 |        â”œâ”€ ğŸ–¼ï¸ colÃ´nia.png
 |        â””â”€ ğŸ–¼ï¸ festy.png
 |
 |  â””â”€ ğŸ“ model/
 |        â””â”€ ğŸ›’ cart_model.dart
 |       
 |  â””â”€ ğŸ“ pages/
 |        â”œâ”€ ğŸ›’ cart_page_screen.dart
 |        â”œâ”€ ğŸ  home_page_screen.dart
 |        â”œâ”€ ğŸ¬ intro_screen.dart
 |        â”œâ”€ ğŸ”’ login_screen.dart
 |        â””â”€ ğŸ“ registration_screen.dart
 |        â””â”€ ğŸ”‘ password_recovery_screen.dart
 |
ğŸ“„ backend_service.dart
ğŸ“„ firebase_options.dart
ğŸ“„ main.dart


========================MANUAL Da APLICAÃ‡ÃƒO======================
PROJETO MOBILE DA SEGUNDA UNIDADE
PROFESSOR: SEVERINO;
DISCIPLINA: MOBILE;
DESAFIO: CONSTRUÃ‡ÃƒO DE UM SISTEMA WEB COMPOSTO POR:
UMA API REST COMO BACKEND, FORNECENDO E PROCESSANDO DADOS E O MODELO DE NEGÃ“CIO;
CLIENTE MOBILE COMO INTERFACE GRÃFICA (front FLUTTER);

DESENVOLVEDORES: GLEYDSON DIAS, MOISÃ‰S JUNIOR, RODRIGO LELLIS, MÃRCIO BRITO, MARCELO GOMES, JOSÃ‰ NETO


Flutter: 

1. ConfiguraÃ§Ã£o do Firebase:
   - Verifique o arquivo `firebase_options.dart` para garantir que as configuraÃ§Ãµes do Firebase estÃ£o corretas.
   - Certifique-se de que a biblioteca Firebase estÃ¡ importada corretamente no arquivo `backend_service.dart`.
   - O arquivo `backend_service.dart` contÃ©m a lÃ³gica de integraÃ§Ã£o com o Firebase para a autenticaÃ§Ã£o e outras funcionalidades relacionadas.

2. AutenticaÃ§Ã£o:
   - O diretÃ³rio `authentication` contÃ©m os arquivos relacionados Ã  autenticaÃ§Ã£o da aplicaÃ§Ã£o.
   - O arquivo `authentication.dart` contÃ©m a lÃ³gica para autenticaÃ§Ã£o e registro de usuÃ¡rios.
   
3. Componentes:
   - O diretÃ³rio `components` contÃ©m o arquivo `ecommerce_items.dart`.
   - Esse arquivo contÃ©m componentes reutilizÃ¡veis â€‹â€‹que sÃ£o usados em vÃ¡rias partes da aplicaÃ§Ã£o.

4. Imagens:
   - O diretÃ³rio `images` contÃ©m os arquivos de imagem `colÃ´nia.png` e `festy.png`.
   - Esses arquivos de imagem  serÃ£o usados para exibir imagens na interface do usuÃ¡rio.

5. Modelo de carrinho:
   - O diretÃ³rio `model` contÃ©m o arquivo `cart_model.dart`.
   - Este arquivo define o modelo para gerenciar o estado do carrinho de compras na aplicaÃ§Ã£o.

6. PÃ¡ginas:
   - O diretÃ³rio `pages` contÃ©m vÃ¡rios arquivos de pÃ¡ginas da aplicaÃ§Ã£o.
   - O arquivo `cart_page.dart` pode ser a pÃ¡gina que exibe o carrinho de compras.
   - O arquivo `home_page_screen.dart`  contÃ©m a pÃ¡gina principal da aplicaÃ§Ã£o.
   - O arquivo `intro_screen.dart` Ã© responsÃ¡vel pela tela de introduÃ§Ã£o do aplicativo.
   - O arquivo `login_screen.dart` Ã© usado para exibir a tela de login.
   - O arquivo `registration_screen.dart` pode ser usado para exibir a tela de registro.

   - O arquivo `passwordrecovery_screen.dart` Ã© responsÃ¡vel por fornecer uma tela para permitir que os usuÃ¡rios recuperem suas senhas.
dependÃªncias utilizadas nesse projeto:

dependÃªncias do projeto

1. `cupertino_icons: ^1.0.6`: Essa dependÃªncia adiciona os Ã­cones do estilo Cupertino, que sÃ£o os Ã­cones usados na interface de usuÃ¡rio do iOS. Ela fornece acesso Ã  classe `CupertinoIcons`, que contÃ©m os Ã­cones especÃ­ficos do iOS.

2. `provider: ^6.1.2`: Esta Ã© uma biblioteca popular do Flutter que oferece recursos avanÃ§ados de gerenciamento de estado. Ela permite a fÃ¡cil implementaÃ§Ã£o do padrÃ£o State Management e ajuda a garantir a separaÃ§Ã£o clara entre a lÃ³gica e a interface do usuÃ¡rio.

3. `google_fonts: ^6.2.1`: Com essa dependÃªncia, vocÃª obtÃ©m acesso a uma grande variedade de fontes personalizadas do Google Fonts. Ela oferece uma maneira fÃ¡cil de usar essas fontes em seu aplicativo Flutter, permitindo que vocÃª defina a famÃ­lia de fonte e seus estilos diretamente no cÃ³digo.

4. `logging: ^1.0.2`: Essa dependÃªncia oferece recursos de log para ajudar no desenvolvimento e depuraÃ§Ã£o do aplicativo. Ela fornece vÃ¡rias classes e utilitÃ¡rios para registrar informaÃ§Ãµes, avisos e erros no console.

5. `firebase_core: ^3.0.0`: Essa dependÃªncia Ã© necessÃ¡ria para a integraÃ§Ã£o com o Firebase. Ela fornece as funcionalidades bÃ¡sicas e a configuraÃ§Ã£o necessÃ¡ria para inicializar o Firebase no seu aplicativo Flutter.

6. `firebase_auth: ^5.0.0`: Com essa dependÃªncia, vocÃª pode usar recursos de autenticaÃ§Ã£o do Firebase, como autenticaÃ§Ã£o por e-mail, autenticaÃ§Ã£o com provedores de terceiros (Google, Facebook, etc.) e gerenciamento de usuÃ¡rios.

7. `http: ^1.2.1`: Essa dependÃªncia fornece uma maneira fÃ¡cil de fazer requisiÃ§Ãµes HTTP em seu aplicativo Flutter. Ela oferece uma API simples e poderosa para enviar e receber dados de APIs RESTful ou outros serviÃ§os web.


Python:
Claro! Vou dar uma breve explicaÃ§Ã£o do cÃ³digo fornecido.

1. ImportaÃ§Ãµes: O cÃ³digo comeÃ§a importando os mÃ³dulos necessÃ¡rios, como o `os` para lidar com caminhos de arquivo e o `Flask` para criar a aplicaÃ§Ã£o Flask. TambÃ©m sÃ£o importados o `jsonify` para criar respostas JSON, o `request` para lidar com as solicitaÃ§Ãµes recebidas e o `SQLAlchemy` para fazer a comunicaÃ§Ã£o com o banco de dados.

2. ConfiguraÃ§Ã£o da aplicaÃ§Ã£o e do banco de dados: A configuraÃ§Ã£o da aplicaÃ§Ã£o Flask Ã© definida usando o objeto `app.config`. Aqui, definimos a URI do banco de dados SQLite e desabilitamos o controle de modificaÃ§Ãµes do SQLAlchemy para evitar avisos.

3. DefiniÃ§Ã£o do modelo: Ã‰ definida uma classe `Venda` que herda de `db.Model` (que Ã© uma classe de modelo fornecida pelo SQLAlchemy). A classe possui alguns campos no banco de dados, como o `id` (chave primÃ¡ria), `item`, `preco` e `imagem`.

4. CriaÃ§Ã£o do banco de dados e tabelas: O bloco `with app.app_context()` Ã© usado para criar todas as tabelas definidas nos modelos. A funÃ§Ã£o `db.create_all()` Ã© usada para criar o banco de dados e as tabelas, caso ainda nÃ£o existam.

5. Rota para receber vendas: A funÃ§Ã£o `receber_venda` Ã© decorada com `@app.route('/api/vendas', methods=['POST'])` para criar uma rota que aceita solicitaÃ§Ãµes POST na URL '/api/vendas'. A funÃ§Ã£o obtÃ©m os dados JSON da solicitaÃ§Ã£o, valida se estÃ£o completos e, em seguida, itera sobre os dados das vendas para criar novas instÃ¢ncias da classe `Venda`. Em seguida, as novas vendas sÃ£o adicionadas Ã  sessÃ£o do banco de dados e o banco de dados Ã© atualizado com `db.session.commit()`.

6. Rota de Ã­ndice: A funÃ§Ã£o `index` Ã© decorada com `@app.route('/', methods=['GET'])` para criar uma rota inicial na raiz do aplicativo Flask. Quando um cliente faz uma solicitaÃ§Ã£o GET para a raiz do aplicativo, a mensagem "Bem-vindo Ã  minha API Flask!" Ã© retornada.

7. Rota para obter itens: A funÃ§Ã£o `get_items` Ã© decorada com `@app.route('/api/items', methods=['GET'])` para criar uma rota que retorna uma resposta JSON com uma lista de itens. Neste exemplo, apenas uma lista estÃ¡tica de itens Ã© retornada.

8. ExecuÃ§Ã£o do aplicativo: Por Ãºltimo, a condiÃ§Ã£o `if __name__ == '__main__':` Ã© usada para garantir que o aplicativo seja executado somente se for o arquivo principal que estÃ¡ sendo executado. O aplicativo Flask Ã© executado com a funÃ§Ã£o `app.run()`.

Em resumo, este Ã© um exemplo bÃ¡sico de uma aplicaÃ§Ã£o Flask. Ele configura um banco de dados SQLite, define um modelo de venda, define rotas para receber vendas, obter itens e exibe uma mensagem de boas-vindas na raiz do aplicativo.


